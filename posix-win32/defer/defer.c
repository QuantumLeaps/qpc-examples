//$file${.::defer.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: defer.qm
// File:  ${.::defer.c}
//
// This code has been generated by QM 7.0.2 <www.state-machine.com/qm>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// Copyright (c) 2005 Quantum Leaps, LLC. All rights reserved.
//
//                 ____________________________________
//                /                                   /
//               /    GGGGGGG    PPPPPPPP   LL       /
//              /   GG     GG   PP     PP  LL       /
//             /   GG          PP     PP  LL       /
//            /   GG   GGGGG  PPPPPPPP   LL       /
//           /   GG      GG  PP         LL       /
//          /     GGGGGGG   PP         LLLLLLL  /
//         /___________________________________/
//
// SPDX-License-Identifier: GPL-3.0-or-later
//
// This generated code is open-source software licensed under the GNU
// General Public License (GPL) as published by the Free Software Foundation
// (see <https://www.gnu.org/licenses>).
//
// NOTE:
// The GPL does NOT permit the incorporation of this code into proprietary
// programs. Please contact Quantum Leaps for commercial licensing options,
// which expressly supersede the GPL and are designed explicitly for
// closed-source distribution.
//
// Quantum Leaps contact information:
// <www.state-machine.com/licensing>
// <info@state-machine.com>
//
//$endhead${.::defer.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#include "qpc.h"    // QP/C real-time event framework
#include "bsp.h"    // Board Support Package interface
#include "app.h"    // Application

Q_DEFINE_THIS_FILE

//$declare${AOs::TServer} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${AOs::TServer} ............................................................
typedef struct TServer {
// protected:
    QActive super;

// public:

// private:
    QEQueue requestQueue;
    QEvtPtr requestQSto[3];

// public:
    RequestEvt const * activeRequest;
    QTimeEvt receivedEvt;
    QTimeEvt authorizedEvt;
} TServer;

extern TServer TServer_inst;

// protected:
static QState TServer_initial(TServer * const me, void const * const par);
static QState TServer_idle(TServer * const me, QEvt const * const e);
static QState TServer_busy(TServer * const me, QEvt const * const e);
static QState TServer_receiving(TServer * const me, QEvt const * const e);
static QState TServer_authorizing(TServer * const me, QEvt const * const e);
static QState TServer_final(TServer * const me, QEvt const * const e);
//$enddecl${AOs::TServer} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
// Check for the minimum required QP version
#if (QP_VERSION < 730U) || (QP_VERSION != ((QP_RELEASE^4294967295U)%0x2710U))
#error qpc version 7.3.0 or higher required
#endif
//$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//$define${App} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${App::AO_TServer} .........................................................
QActive * const AO_TServer = (QActive *)&TServer_inst;

//${App::TServer_ctor} .......................................................
void TServer_ctor(void) {
    TServer * const me = &TServer_inst;

    QActive_ctor(&me->super, Q_STATE_CAST(&TServer_initial));
    QEQueue_init(&me->requestQueue,
                 me->requestQSto, Q_DIM(me->requestQSto));
    QTimeEvt_ctorX(&me->receivedEvt,   &me->super, RECEIVED_SIG,   0U);
    QTimeEvt_ctorX(&me->authorizedEvt, &me->super, AUTHORIZED_SIG, 0U);
}
//$enddef${App} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//$define${AOs::TServer} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${AOs::TServer} ............................................................
TServer TServer_inst;

//${AOs::TServer::SM} ........................................................
static QState TServer_initial(TServer * const me, void const * const par) {
    //${AOs::TServer::SM::initial}
    (void)par; // unused parameter
    me->activeRequest = (RequestEvt const *)0; // no active request yet

    QS_OBJ_DICTIONARY(&TServer_inst);
    QS_OBJ_DICTIONARY(&TServer_inst.receivedEvt);
    QS_OBJ_DICTIONARY(&TServer_inst.authorizedEvt);
    QS_OBJ_DICTIONARY(&TServer_inst.requestQueue);

    QS_FUN_DICTIONARY(&TServer_idle);
    QS_FUN_DICTIONARY(&TServer_busy);
    QS_FUN_DICTIONARY(&TServer_receiving);
    QS_FUN_DICTIONARY(&TServer_authorizing);
    QS_FUN_DICTIONARY(&TServer_final);

    return Q_TRAN(&TServer_idle);
}

//${AOs::TServer::SM::idle} ..................................................
static QState TServer_idle(TServer * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${AOs::TServer::SM::idle}
        case Q_ENTRY_SIG: {
            BSP_showMsg("idle-ENTRY\n", 0U);

            // recall the oldest deferred request...
            if (QActive_recall(&me->super, &me->requestQueue)) {
                BSP_showMsg("Request recalled\n", 0U);
            }
            else {
                BSP_showMsg("No deferred requests\n", 0U);
            }
            status_ = Q_HANDLED();
            break;
        }
        //${AOs::TServer::SM::idle::NEW_REQUEST}
        case NEW_REQUEST_SIG: {
            // create and save a new reference to the request event so that
            // this event will be available beyond this RTC step and won't be
            // recycled.
            Q_NEW_REF(me->activeRequest, RequestEvt);

            BSP_showMsg("Processing request #%d\n",
                Q_EVT_CAST(RequestEvt)->ref_num);
            status_ = Q_TRAN(&TServer_receiving);
            break;
        }
        //${AOs::TServer::SM::idle::TERMINATE}
        case TERMINATE_SIG: {
            status_ = Q_TRAN(&TServer_final);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

//${AOs::TServer::SM::busy} ..................................................
static QState TServer_busy(TServer * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${AOs::TServer::SM::busy}
        case Q_EXIT_SIG: {
            BSP_showMsg("busy-EXIT; done processing request #%d\n",
                me->activeRequest->ref_num);

            // delete the reference to the active request, because
            // it is now processed.
            Q_DELETE_REF(me->activeRequest);
            status_ = Q_HANDLED();
            break;
        }
        //${AOs::TServer::SM::busy::NEW_REQUEST}
        case NEW_REQUEST_SIG: {
            // defer the new request event...
            if (QActive_defer(&me->super, &me->requestQueue, e)) {
                BSP_showMsg("Deferred request #%d\n",
                    Q_EVT_CAST(RequestEvt)->ref_num);
            }
            else { // deferred queue full
                // option1: ignore the new request and do nothing here

                // option2:
                // flush the oldest request to make room for the new one
                QEvt const *old_evt = QEQueue_get(&me->requestQueue, 0U);
                Q_ASSERT(old_evt != (QEvt *)0);
                BSP_showMsg("DISCARDED request #%d\n",
                    ((RequestEvt*)old_evt)->ref_num);
                QF_gc(old_evt); // explicitly recycle old

                // repeat the defer request after making room in the queue
                if (!QActive_defer(&me->super, &me->requestQueue, e)) {
                    Q_ERROR(); // now it must succeed
                }
            }
            status_ = Q_HANDLED();
            break;
        }
        //${AOs::TServer::SM::busy::TERMINATE}
        case TERMINATE_SIG: {
            status_ = Q_TRAN(&TServer_final);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

//${AOs::TServer::SM::busy::receiving} .......................................
static QState TServer_receiving(TServer * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${AOs::TServer::SM::busy::receiving}
        case Q_ENTRY_SIG: {
            // inform about the first stage of processing of the request...
            BSP_showMsg("receiving-ENTRY; active request #%d\n",
                me->activeRequest->ref_num);

            // one-shot timeout in 1 second
            QTimeEvt_armX(&me->receivedEvt, BSP_TICKS_PER_SEC, 0U);
            status_ = Q_HANDLED();
            break;
        }
        //${AOs::TServer::SM::busy::receiving}
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->receivedEvt);
            status_ = Q_HANDLED();
            break;
        }
        //${AOs::TServer::SM::busy::receiving::RECEIVED}
        case RECEIVED_SIG: {
            status_ = Q_TRAN(&TServer_authorizing);
            break;
        }
        default: {
            status_ = Q_SUPER(&TServer_busy);
            break;
        }
    }
    return status_;
}

//${AOs::TServer::SM::busy::authorizing} .....................................
static QState TServer_authorizing(TServer * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${AOs::TServer::SM::busy::authorizing}
        case Q_ENTRY_SIG: {
            // inform about the second stage of processing of the request..
            BSP_showMsg("authorizing-ENTRY; active request #%d\n",
                me->activeRequest->ref_num);

            // one-shot timeout in 2 seconds
            QTimeEvt_armX(&me->authorizedEvt, 2U*BSP_TICKS_PER_SEC, 0U);
            status_ = Q_HANDLED();
            break;
        }
        //${AOs::TServer::SM::busy::authorizing}
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->authorizedEvt);
            status_ = Q_HANDLED();
            break;
        }
        //${AOs::TServer::SM::busy::authorizing::AUTHORIZED}
        case AUTHORIZED_SIG: {
            status_ = Q_TRAN(&TServer_idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&TServer_busy);
            break;
        }
    }
    return status_;
}

//${AOs::TServer::SM::final} .................................................
static QState TServer_final(TServer * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${AOs::TServer::SM::final}
        case Q_ENTRY_SIG: {
            BSP_showMsg("final-ENTRY; request\n", 0U);
            QF_stop(); // terminate the application
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
//$enddef${AOs::TServer} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
