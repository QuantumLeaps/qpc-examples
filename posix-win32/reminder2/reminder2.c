//$file${.::reminder2.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: reminder2.qm
// File:  ${.::reminder2.c}
//
// This code has been generated by QM 7.0.2 <www.state-machine.com/qm>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// Copyright (c) 2005 Quantum Leaps, LLC. All rights reserved.
//
//                 ____________________________________
//                /                                   /
//               /    GGGGGGG    PPPPPPPP   LL       /
//              /   GG     GG   PP     PP  LL       /
//             /   GG          PP     PP  LL       /
//            /   GG   GGGGG  PPPPPPPP   LL       /
//           /   GG      GG  PP         LL       /
//          /     GGGGGGG   PP         LLLLLLL  /
//         /___________________________________/
//
// SPDX-License-Identifier: GPL-3.0-or-later
//
// This generated code is open-source software licensed under the GNU
// General Public License (GPL) as published by the Free Software Foundation
// (see <https://www.gnu.org/licenses>).
//
// NOTE:
// The GPL does NOT permit the incorporation of this code into proprietary
// programs. Please contact Quantum Leaps for commercial licensing options,
// which expressly supersede the GPL and are designed explicitly for
// closed-source distribution.
//
// Quantum Leaps contact information:
// <www.state-machine.com/licensing>
// <info@state-machine.com>
//
//$endhead${.::reminder2.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#include "qpc.h"        // QP/C real-time evetn framework
#include "bsp.h"        // Board Support Package interface
#include "app.h"        // Application

//Q_DEFINE_THIS_FILE

//$declare${AOs::Cruncher} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${AOs::Cruncher} ...........................................................
typedef struct Cruncher {
// protected:
    QActive super;

// public:

// private:

    // internal variable
    double sum;
} Cruncher;

extern Cruncher Cruncher_inst;

// protected:
static QState Cruncher_initial(Cruncher * const me, void const * const par);
static QState Cruncher_processing(Cruncher * const me, QEvt const * const e);
static QState Cruncher_final(Cruncher * const me, QEvt const * const e);
//$enddecl${AOs::Cruncher} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
// Check for the minimum required QP version
#if (QP_VERSION < 730U) || (QP_VERSION != ((QP_RELEASE^4294967295U)%0x2710U))
#error qpc version 7.3.0 or higher required
#endif
//$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//$define${App} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${App::ReminderEvt} ........................................................

//${App::Cruncher_ctor} ......................................................
void Cruncher_ctor(void) {
    Cruncher * const me = &Cruncher_inst;
    QActive_ctor((QActive *)me, Q_STATE_CAST(&Cruncher_initial));
}

//${App::AO_Cruncher} ........................................................
QActive * const AO_Cruncher = (QActive *)&Cruncher_inst;
//$enddef${App} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//$define${AOs::Cruncher} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

//${AOs::Cruncher} ...........................................................
Cruncher Cruncher_inst;

//${AOs::Cruncher::SM} .......................................................
static QState Cruncher_initial(Cruncher * const me, void const * const par) {
    //${AOs::Cruncher::SM::initial}
    Q_UNUSED_PAR(par);
    return Q_TRAN(&Cruncher_processing);
}

//${AOs::Cruncher::SM::processing} ...........................................
static QState Cruncher_processing(Cruncher * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${AOs::Cruncher::SM::processing}
        case Q_ENTRY_SIG: {
            #ifdef QEVT_PAR_INIT
            ReminderEvt *reminder = Q_NEW(ReminderEvt, CRUNCH_SIG, 0U);
            #else
            ReminderEvt *reminder = Q_NEW(ReminderEvt, CRUNCH_SIG);
            reminder->iter = 0U;
            #endif

            QACTIVE_POST((QActive *)me, &reminder->super, me);
            me->sum = 0.0;
            status_ = Q_HANDLED();
            break;
        }
        //${AOs::Cruncher::SM::processing::CRUNCH}
        case CRUNCH_SIG: {
            uint32_t n = Q_EVT_CAST(ReminderEvt)->iter;
            uint32_t const iter = n + 100U;
            for (; n < iter; ++n) {
                if ((n & 1U) == 0U) {
                    me->sum += 1.0/(2U*n + 1U);
                }
                else {
                    me->sum -= 1.0/(2U*n + 1U);
                }
            }
            //${AOs::Cruncher::SM::processing::CRUNCH::[iter<0x07000000U]}
            if (iter < 0x07000000U) {
                #ifdef QEVT_PAR_INIT
                ReminderEvt *reminder = Q_NEW(ReminderEvt, CRUNCH_SIG, iter);
                #else
                ReminderEvt *reminder = Q_NEW(ReminderEvt, CRUNCH_SIG);
                reminder->iter = iter;
                #endif

                QACTIVE_POST((QActive *)me, &reminder->super, me);
                status_ = Q_HANDLED();
            }
            //${AOs::Cruncher::SM::processing::CRUNCH::[else]}
            else {
                BSP_showMsg("pi=%16.14f\n", 4.0 * me->sum);
                status_ = Q_TRAN(&Cruncher_processing);
            }
            break;
        }
        //${AOs::Cruncher::SM::processing::ECHO}
        case ECHO_SIG: {
            BSP_showMsg("Echo! pi=%16.14f\n", 4.0 * me->sum);
            status_ = Q_HANDLED();
            break;
        }
        //${AOs::Cruncher::SM::processing::TERMINATE}
        case TERMINATE_SIG: {
            status_ = Q_TRAN(&Cruncher_final);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

//${AOs::Cruncher::SM::final} ................................................
static QState Cruncher_final(Cruncher * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        //${AOs::Cruncher::SM::final}
        case Q_ENTRY_SIG: {
            BSP_showMsg("final-ENTRY;\n", 0.0);
            QF_stop(); // terminate the application
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
//$enddef${AOs::Cruncher} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
