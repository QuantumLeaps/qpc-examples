        -:    0:Source:../../../../src/qf/qep_msm.c
        -:    0:Graph:build/qep_msm.gcno
        -:    0:Data:build/qep_msm.gcda
        -:    0:Runs:6
        -:    1://$file${src::qf::qep_msm.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
        -:    2://
        -:    3:// Model: qpc.qm
        -:    4:// File:  ${src::qf::qep_msm.c}
        -:    5://
        -:    6:// This code has been generated by QM 7.0.0 <www.state-machine.com/qm>.
        -:    7:// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
        -:    8://
        -:    9:// This code is covered by the following QP license:
        -:   10:// License #    : LicenseRef-QL-dual
        -:   11:// Issued to    : General public
        -:   12:// Framework(s) : qpc
        -:   13:// Support ends : 2025-12-31
        -:   14:// License scope:
        -:   15://
        -:   16:// Copyright (C) 2005 Quantum Leaps, LLC. All rights reserved.
        -:   17://
        -:   18://                    Q u a n t u m  L e a P s
        -:   19://                    ------------------------
        -:   20://                    Modern Embedded Software
        -:   21://
        -:   22:// SPDX-License-Identifier: GPL-3.0-or-later OR LicenseRef-QL-commercial
        -:   23://
        -:   24:// The QP/C software is dual-licensed under the terms of the open-source GNU
        -:   25:// General Public License (GPL) or under the terms of one of the closed-
        -:   26:// source Quantum Leaps commercial licenses.
        -:   27://
        -:   28:// Redistributions in source code must retain this top-level comment block.
        -:   29:// Plagiarizing this software to sidestep the license obligations is illegal.
        -:   30://
        -:   31:// NOTE:
        -:   32:// The GPL (see <www.gnu.org/licenses/gpl-3.0>) does NOT permit the
        -:   33:// incorporation of the QP/C software into proprietary programs. Please
        -:   34:// contact Quantum Leaps for commercial licensing options, which expressly
        -:   35:// supersede the GPL and are designed explicitly for licensees interested
        -:   36:// in using QP/C in closed-source proprietary applications.
        -:   37://
        -:   38:// Quantum Leaps contact information:
        -:   39:// <www.state-machine.com/licensing>
        -:   40:// <info@state-machine.com>
        -:   41://
        -:   42://$endhead${src::qf::qep_msm.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        -:   43:#define QP_IMPL           // this is QP implementation
        -:   44:#include "qp_port.h"      // QP port
        -:   45:#include "qp_pkg.h"       // QP package-scope interface
        -:   46:#include "qsafe.h"        // QP Functional Safety (FuSa) Subsystem
        -:   47:#ifdef Q_SPY              // QS software tracing enabled?
        -:   48:    #include "qs_port.h"  // QS port
        -:   49:    #include "qs_pkg.h"   // QS facilities for pre-defined trace records
        -:   50:#else
        -:   51:    #include "qs_dummy.h" // disable the QS software tracing
        -:   52:#endif // Q_SPY
        -:   53:
        -:   54://============================================================================
        -:   55://! @cond INTERNAL
        -:   56:
        -:   57:Q_DEFINE_THIS_MODULE("qep_msm")
        -:   58:
        -:   59:// top-state object for QMsm-style state machines
        -:   60:static struct QMState const l_msm_top_s = {
        -:   61:    (struct QMState *)0,
        -:   62:    Q_STATE_CAST(0),
        -:   63:    Q_ACTION_CAST(0),
        -:   64:    Q_ACTION_CAST(0),
        -:   65:    Q_ACTION_CAST(0)
        -:   66:};
        -:   67://! @endcond
        -:   68:
        -:   69:enum {
        -:   70:    // maximum depth of state nesting in a QMsm (including the top level)
        -:   71:    QMSM_MAX_NEST_DEPTH_  = 8,
        -:   72:
        -:   73:    // maximum length of transition-action array
        -:   74:    QMSM_MAX_TRAN_LENGTH_ = 2*QMSM_MAX_NEST_DEPTH_,
        -:   75:
        -:   76:    // maximum depth of entry levels in a MSM for tran. to history
        -:   77:    QMSM_MAX_ENTRY_DEPTH_ = 4
        -:   78:};
        -:   79:
        -:   80://============================================================================
        -:   81:
        -:   82://$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
        -:   83:// Check for the minimum required QP version
        -:   84:#if (QP_VERSION < 750U) || (QP_VERSION != ((QP_RELEASE^4294967295U)%0x2710U))
        -:   85:#error qpc version 7.5.0 or higher required
        -:   86:#endif
        -:   87://$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        -:   88://$define${QEP::QMsm} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
        -:   89:
        -:   90://${QEP::QMsm} ...............................................................
        -:   91:
        -:   92://${QEP::QMsm::ctor} .........................................................
        -:   93://! @protected @memberof QMsm
        6:   94:void QMsm_ctor(QMsm * const me,
        -:   95:    QStateHandler const initial)
        -:   96:{
        6:   97:    static struct QAsmVtable const vtable = { // QAsm virtual table
        -:   98:        &QMsm_init_,
        -:   99:        &QMsm_dispatch_,
        -:  100:        &QMsm_isIn_
        -:  101:    #ifdef Q_SPY
        -:  102:        ,&QMsm_getStateHandler_
        -:  103:    #endif
        -:  104:    };
        -:  105:    // do not call the QAsm_ctor() here
        6:  106:    me->super.vptr = &vtable;
        6:  107:    me->super.state.obj = &l_msm_top_s; // the current state (top)
        6:  108:    me->super.temp.fun  = initial;      // the initial tran. handler
        6:  109:}
        -:  110:
        -:  111://${QEP::QMsm::init_} ........................................................
        -:  112://! @private @memberof QMsm
        6:  113:void QMsm_init_(
        -:  114:    QAsm * const me,
        -:  115:    void const * const e,
        -:  116:    uint_fast8_t const qsId)
        -:  117:{
        -:  118:    #ifndef Q_SPY
        -:  119:    Q_UNUSED_PAR(qsId);
        -:  120:    #endif
        -:  121:
        -:  122:    QF_CRIT_STAT
        6:  123:    QF_CRIT_ENTRY();
       6*:  124:    Q_REQUIRE_INCRIT(200, (me->vptr != (struct QAsmVtable *)0)
        -:  125:                      && (me->temp.fun != Q_STATE_CAST(0))
        -:  126:                      && (me->state.obj == &l_msm_top_s));
        6:  127:    QF_CRIT_EXIT();
        -:  128:
        -:  129:    // execute the top-most initial tran.
        6:  130:    QState r = (*me->temp.fun)(me, Q_EVT_CAST(QEvt));
        -:  131:
        6:  132:    QF_CRIT_ENTRY();
        -:  133:    // the top-most initial tran. must be taken
       6*:  134:    Q_ASSERT_INCRIT(210, r == Q_RET_TRAN_INIT);
        -:  135:
        6:  136:    QS_MEM_SYS();
        6:  137:    QS_BEGIN_PRE_(QS_QEP_STATE_INIT, qsId)
        3:  138:        QS_OBJ_PRE_(me); // this state machine object
        3:  139:        QS_FUN_PRE_(me->state.obj->stateHandler);          // source state
        3:  140:        QS_FUN_PRE_(me->temp.tatbl->target->stateHandler); // target state
        3:  141:    QS_END_PRE_()
        6:  142:    QS_MEM_APP();
        -:  143:
        6:  144:    QF_CRIT_EXIT();
        -:  145:
        -:  146:    // set state to the last tran. target
        6:  147:    me->state.obj = me->temp.tatbl->target;
        -:  148:
        -:  149:    // drill down into the state hierarchy with initial transitions...
        6:  150:    int_fast8_t lbound = QMSM_MAX_NEST_DEPTH_; // fixed upper loop bound
       12:  151:    do {
        -:  152:        // execute the tran. table
       12:  153:        r = QMsm_execTatbl_(me, me->temp.tatbl, qsId);
       12:  154:        --lbound;
       12:  155:    } while ((r >= Q_RET_TRAN_INIT) && (lbound > 0));
        -:  156:
        6:  157:    QF_CRIT_ENTRY();
       6*:  158:    Q_ENSURE_INCRIT(290, lbound > 0);
        -:  159:
        6:  160:    QS_MEM_SYS();
        6:  161:    QS_BEGIN_PRE_(QS_QEP_INIT_TRAN, qsId)
        3:  162:        QS_TIME_PRE_();    // time stamp
        3:  163:        QS_OBJ_PRE_(me);   // this state machine object
        3:  164:        QS_FUN_PRE_(me->state.obj->stateHandler); // the new current state
        3:  165:    QS_END_PRE_()
        6:  166:    QS_MEM_APP();
        -:  167:
        6:  168:    QF_CRIT_EXIT();
        -:  169:
        -:  170:    #ifndef Q_UNSAFE
        6:  171:    me->temp.uint = ~me->state.uint;
        -:  172:    #endif
        6:  173:}
        -:  174:
        -:  175://${QEP::QMsm::dispatch_} ....................................................
        -:  176://! @private @memberof QMsm
       41:  177:void QMsm_dispatch_(
        -:  178:    QAsm * const me,
        -:  179:    QEvt const * const e,
        -:  180:    uint_fast8_t const qsId)
        -:  181:{
        -:  182:    #ifndef Q_SPY
        -:  183:    Q_UNUSED_PAR(qsId);
        -:  184:    #endif
        -:  185:
       41:  186:    QMState const *s = me->state.obj; // store the current state
       41:  187:    QMState const *t = s;
        -:  188:
        -:  189:    QF_CRIT_STAT
       41:  190:    QF_CRIT_ENTRY();
      82*:  191:    Q_REQUIRE_INCRIT(300, QEvt_verify_(e));
      41*:  192:    Q_INVARIANT_INCRIT(302, (s != (QMState *)0)
        -:  193:        && (me->state.uint == (uintptr_t)(~me->temp.uint)));
        -:  194:
       41:  195:    QS_MEM_SYS();
       41:  196:    QS_BEGIN_PRE_(QS_QEP_DISPATCH, qsId)
       21:  197:        QS_TIME_PRE_();               // time stamp
       21:  198:        QS_SIG_PRE_(e->sig);          // the signal of the event
       21:  199:        QS_OBJ_PRE_(me);              // this state machine object
       21:  200:        QS_FUN_PRE_(s->stateHandler); // the current state handler
       21:  201:    QS_END_PRE_()
       41:  202:    QS_MEM_APP();
        -:  203:
       41:  204:    QF_CRIT_EXIT();
        -:  205:
        -:  206:    // scan the state hierarchy up to the top state...
       41:  207:    QState r;
       41:  208:    int_fast8_t lbound = QMSM_MAX_NEST_DEPTH_; // fixed upper loop bound
       90:  209:    do {
       90:  210:        r = (*t->stateHandler)(me, e); // call state handler function
        -:  211:
        -:  212:        // event handled? (the most frequent case)
       90:  213:        if (r >= Q_RET_HANDLED) {
        -:  214:            break; // done scanning the state hierarchy
        -:  215:        }
        -:  216:        // event unhandled and passed to the superstate?
       52:  217:        else if (r == Q_RET_SUPER) {
       48:  218:            t = t->superstate; // advance to the superstate
        -:  219:        }
        -:  220:        else { // event unhandled due to a guard
        4:  221:            QF_CRIT_ENTRY();
        -:  222:            // event must be unhandled due to a guard evaluating to 'false'
       4*:  223:            Q_ASSERT_INCRIT(310, r == Q_RET_UNHANDLED);
        -:  224:
        4:  225:            QS_MEM_SYS();
        4:  226:            QS_BEGIN_PRE_(QS_QEP_UNHANDLED, qsId)
        2:  227:                QS_SIG_PRE_(e->sig);  // the signal of the event
        2:  228:                QS_OBJ_PRE_(me);      // this state machine object
        2:  229:                QS_FUN_PRE_(t->stateHandler); // the current state
        2:  230:            QS_END_PRE_()
        4:  231:            QS_MEM_APP();
        -:  232:
        4:  233:            QF_CRIT_EXIT();
        -:  234:
        4:  235:            t = t->superstate; // advance to the superstate
        -:  236:        }
       52:  237:        --lbound;
       52:  238:    } while ((t != (QMState *)0) && (lbound > 0));
       41:  239:    QF_CRIT_ENTRY();
      41*:  240:    Q_ENSURE_INCRIT(320, lbound > 0);
       41:  241:    QF_CRIT_EXIT();
        -:  242:
       41:  243:    if (r >= Q_RET_TRAN) { // any kind of tran. taken?
       34:  244:        QF_CRIT_ENTRY();
        -:  245:        // the tran. source state must not be NULL
      34*:  246:        Q_ASSERT_INCRIT(330, t != (QMState *)0);
       34:  247:        QF_CRIT_EXIT();
        -:  248:
        -:  249:    #ifdef Q_SPY
       34:  250:        QMState const * const ts = t; // tran. source for QS tracing
        -:  251:    #endif // Q_SPY
       34:  252:        struct QMTranActTable const *tatbl; // for saving tran. table
        -:  253:
       34:  254:        if (r == Q_RET_TRAN_HIST) { // was it tran. to history?
        8:  255:            QMState const *hist = me->state.obj; // save history
        8:  256:            me->state.obj = s; // restore the original state
        -:  257:
        8:  258:            QS_CRIT_ENTRY();
        8:  259:            QS_MEM_SYS();
        8:  260:            QS_BEGIN_PRE_(QS_QEP_TRAN_HIST, qsId)
        4:  261:                QS_OBJ_PRE_(me); // this state machine object
        4:  262:                QS_FUN_PRE_(t->stateHandler);    // source state handler
        4:  263:                QS_FUN_PRE_(hist->stateHandler); // target state handler
        4:  264:            QS_END_PRE_()
        8:  265:            QS_MEM_APP();
        8:  266:            QS_CRIT_EXIT();
        -:  267:
        -:  268:            // save the tran-action table before it gets clobbered
        8:  269:            tatbl = me->temp.tatbl;
        8:  270:            QMsm_exitToTranSource_(me, s, t, qsId);
        8:  271:            (void)QMsm_execTatbl_(me, tatbl, qsId);
        8:  272:            r = QMsm_enterHistory_(me, hist, qsId);
        8:  273:            s = me->state.obj;
        8:  274:            t = s; // set target to the current state
        -:  275:        }
        -:  276:
        -:  277:        lbound = QMSM_MAX_NEST_DEPTH_; // fixed upper loop bound
       76:  278:        while ((r >= Q_RET_TRAN) && (lbound > 0)) {
        -:  279:            // save the tran-action table before it gets clobbered
       42:  280:            tatbl = me->temp.tatbl;
       42:  281:            me->temp.obj = (QMState *)0; // clear
       42:  282:            QMsm_exitToTranSource_(me, s, t, qsId);
       42:  283:            r = QMsm_execTatbl_(me, tatbl, qsId);
       42:  284:            s = me->state.obj;
       42:  285:            t = s; // set target to the current state
       42:  286:            --lbound;
        -:  287:        }
        -:  288:
       34:  289:        QF_CRIT_ENTRY();
      34*:  290:        Q_ENSURE_INCRIT(360, lbound > 0);
        -:  291:
       34:  292:        QS_MEM_SYS();
       34:  293:        QS_BEGIN_PRE_(QS_QEP_TRAN, qsId)
       17:  294:            QS_TIME_PRE_();                 // time stamp
       17:  295:            QS_SIG_PRE_(e->sig);            // the signal of the event
       17:  296:            QS_OBJ_PRE_(me);                // this state machine object
       17:  297:            QS_FUN_PRE_(ts->stateHandler);  // the tran. source
       17:  298:            QS_FUN_PRE_(s->stateHandler);   // the new active state
       17:  299:        QS_END_PRE_()
       34:  300:        QS_MEM_APP();
        -:  301:
       34:  302:        QF_CRIT_EXIT();
        -:  303:    }
        -:  304:
        -:  305:    #ifdef Q_SPY
        -:  306:    // was the event handled?
        7:  307:    else if (r == Q_RET_HANDLED) {
        4:  308:        QF_CRIT_ENTRY();
        -:  309:        // internal tran. source can't be NULL
       4*:  310:        Q_ASSERT_INCRIT(380, t != (QMState *)0);
        -:  311:
        4:  312:        QS_MEM_SYS();
        4:  313:        QS_BEGIN_PRE_(QS_QEP_INTERN_TRAN, qsId)
        2:  314:            QS_TIME_PRE_();                 // time stamp
        2:  315:            QS_SIG_PRE_(e->sig);            // the signal of the event
        2:  316:            QS_OBJ_PRE_(me);                // this state machine object
        2:  317:            QS_FUN_PRE_(t->stateHandler);   // the source state
        2:  318:        QS_END_PRE_()
        4:  319:        QS_MEM_APP();
        -:  320:
        4:  321:        QF_CRIT_EXIT();
        -:  322:    }
        -:  323:    // event bubbled to the 'top' state?
        3:  324:    else if (t == (QMState *)0) {
        3:  325:        QS_CRIT_ENTRY();
        -:  326:        // current state can't be NULL
        3:  327:        Q_ASSERT_INCRIT(390, s != (QMState *)0);
        -:  328:
        3:  329:        QS_MEM_SYS();
        3:  330:        QS_BEGIN_PRE_(QS_QEP_IGNORED, qsId)
        2:  331:            QS_TIME_PRE_();                 // time stamp
        2:  332:            QS_SIG_PRE_(e->sig);            // the signal of the event
        2:  333:            QS_OBJ_PRE_(me);                // this state machine object
        2:  334:            QS_FUN_PRE_(s->stateHandler);   // the current state
        2:  335:        QS_END_PRE_()
        3:  336:        QS_MEM_APP();
        3:  337:        QS_CRIT_EXIT();
        -:  338:    }
        -:  339:    #endif // Q_SPY
        -:  340:    else {
        -:  341:        // empty
       41:  342:    }
        -:  343:
        -:  344:    #ifndef Q_UNSAFE
       41:  345:    me->temp.uint = ~me->state.uint;
        -:  346:    #endif
       41:  347:}
        -:  348:
        -:  349://${QEP::QMsm::isIn_} ........................................................
        -:  350://! @private @memberof QMsm
       11:  351:bool QMsm_isIn_(
        -:  352:    QAsm * const me,
        -:  353:    QStateHandler const state)
        -:  354:{
       11:  355:    bool inState = false; // assume that this SM is not in 'state'
        -:  356:
       11:  357:    QMState const *s = me->state.obj;
       11:  358:    int_fast8_t lbound = QMSM_MAX_NEST_DEPTH_; // fixed upper loop bound
       26:  359:    for (; (s != (QMState *)0) && (lbound > 0); --lbound) {
       23:  360:        if (s->stateHandler == state) { // match found?
        -:  361:            inState = true;
        -:  362:            break;
        -:  363:        }
        -:  364:        else {
       15:  365:            s = s->superstate; // advance to the superstate
        -:  366:        }
        -:  367:    }
        -:  368:
        -:  369:    QF_CRIT_STAT
       11:  370:    QF_CRIT_ENTRY();
      11*:  371:    Q_ENSURE_INCRIT(490, lbound > 0);
       11:  372:    QF_CRIT_EXIT();
        -:  373:
       11:  374:    return inState;
        -:  375:}
        -:  376:
        -:  377://${QEP::QMsm::childStateObj} ................................................
        -:  378://! @public @memberof QMsm
       10:  379:QMState const * QMsm_childStateObj(QMsm const * const me,
        -:  380:    QMState const * const parent)
        -:  381:{
       10:  382:    QMState const *child = me->super.state.obj;
       10:  383:    bool isFound = false; // start with the child not found
       10:  384:    QMState const *s;
        -:  385:
       10:  386:    int_fast8_t lbound = QMSM_MAX_NEST_DEPTH_; // fixed upper loop bound
       10:  387:    for (s = me->super.state.obj;
       34:  388:         (s != (QMState *)0) && (lbound > 0);
       24:  389:         s = s->superstate)
        -:  390:    {
       34:  391:        if (s == parent) {
        -:  392:            isFound = true; // child is found
        -:  393:            break;
        -:  394:        }
        -:  395:        else {
       24:  396:            child = s;
        -:  397:        }
       24:  398:        --lbound;
        -:  399:    }
        -:  400:    QF_CRIT_STAT
       10:  401:    QF_CRIT_ENTRY();
      10*:  402:    Q_ENSURE_INCRIT(680, lbound > 0);
       10:  403:    QF_CRIT_EXIT();
        -:  404:
       10:  405:    if (!isFound) { // still not found?
    #####:  406:        lbound = QMSM_MAX_NEST_DEPTH_; // fixed upper loop bound
    #####:  407:        for (s = me->super.temp.obj;
    #####:  408:             (s != (QMState *)0) && (lbound > 0);
    #####:  409:             s = s->superstate)
        -:  410:        {
    #####:  411:            if (s == parent) {
        -:  412:                isFound = true; // child is found
        -:  413:                break;
        -:  414:            }
        -:  415:            else {
    #####:  416:                child = s;
        -:  417:            }
    #####:  418:            --lbound;
        -:  419:        }
        -:  420:    }
        -:  421:
       10:  422:    QF_CRIT_ENTRY();
        -:  423:    // NOTE: the following postcondition can only succeed when
        -:  424:    // (lbound > 0), so no extra check is necessary.
      10*:  425:    Q_ENSURE_INCRIT(690, isFound);
       10:  426:    QF_CRIT_EXIT();
        -:  427:
       10:  428:    return child; // return the child
        -:  429:}
        -:  430:
        -:  431://${QEP::QMsm::execTatbl_} ...................................................
        -:  432://! @private @memberof QMsm
       62:  433:QState QMsm_execTatbl_(
        -:  434:    QAsm * const me,
        -:  435:    QMTranActTable const * const tatbl,
        -:  436:    uint_fast8_t const qsId)
        -:  437:{
        -:  438:    #ifndef Q_SPY
        -:  439:    Q_UNUSED_PAR(qsId);
        -:  440:    #endif
        -:  441:
        -:  442:    QF_CRIT_STAT
       62:  443:    QF_CRIT_ENTRY();
        -:  444:    // precondition:
        -:  445:    // - the tran-action table pointer must not be NULL
      62*:  446:    Q_REQUIRE_INCRIT(700, tatbl != (struct QMTranActTable *)0);
       62:  447:    QF_CRIT_EXIT();
        -:  448:
       62:  449:    QState r = Q_RET_NULL;
       62:  450:    int_fast8_t lbound = QMSM_MAX_TRAN_LENGTH_; // fixed upper loop bound
       62:  451:    QActionHandler const *a = &tatbl->act[0];
      198:  452:    for (; (*a != Q_ACTION_CAST(0)) && (lbound > 0); ++a) {
      136:  453:        r = (*(*a))(me); // call the action through the 'a' pointer
      136:  454:        --lbound;
        -:  455:    #ifdef Q_SPY
      136:  456:        QS_CRIT_ENTRY();
      136:  457:        QS_MEM_SYS();
      136:  458:        if (r == Q_RET_ENTRY) {
       80:  459:            QS_BEGIN_PRE_(QS_QEP_STATE_ENTRY, qsId)
       40:  460:                QS_OBJ_PRE_(me); // this state machine object
       40:  461:                QS_FUN_PRE_(me->temp.obj->stateHandler); // entered state
       40:  462:            QS_END_PRE_()
        -:  463:        }
       56:  464:        else if (r == Q_RET_EXIT) {
       38:  465:            QS_BEGIN_PRE_(QS_QEP_STATE_EXIT, qsId)
       19:  466:                QS_OBJ_PRE_(me); // this state machine object
       19:  467:                QS_FUN_PRE_(me->temp.obj->stateHandler); // exited state
       19:  468:            QS_END_PRE_()
        -:  469:        }
       18:  470:        else if (r == Q_RET_TRAN_INIT) {
       18:  471:            QS_BEGIN_PRE_(QS_QEP_STATE_INIT, qsId)
        9:  472:                QS_OBJ_PRE_(me); // this state machine object
        9:  473:                QS_FUN_PRE_(tatbl->target->stateHandler);          // source
        9:  474:                QS_FUN_PRE_(me->temp.tatbl->target->stateHandler); // target
        9:  475:            QS_END_PRE_()
        -:  476:        }
        -:  477:        else {
        -:  478:            // empty
      136:  479:        }
      136:  480:        QS_MEM_APP();
      136:  481:        QS_CRIT_EXIT();
        -:  482:    #endif // Q_SPY
        -:  483:    }
       62:  484:    QF_CRIT_ENTRY();
        -:  485:    // NOTE: the following postcondition can only succeed when
        -:  486:    // (lbound > 0), so no extra check is necessary.
      62*:  487:    Q_ENSURE_INCRIT(790, *a == Q_ACTION_CAST(0));
       62:  488:    QF_CRIT_EXIT();
        -:  489:
       62:  490:    me->state.obj = (r >= Q_RET_TRAN)
       18:  491:        ? me->temp.tatbl->target
        -:  492:        : tatbl->target;
       62:  493:    return r;
        -:  494:}
        -:  495:
        -:  496://${QEP::QMsm::exitToTranSource_} ............................................
        -:  497://! @private @memberof QMsm
       50:  498:void QMsm_exitToTranSource_(
        -:  499:    QAsm * const me,
        -:  500:    QMState const * const cs,
        -:  501:    QMState const * const ts,
        -:  502:    uint_fast8_t const qsId)
        -:  503:{
        -:  504:    #ifndef Q_SPY
        -:  505:    Q_UNUSED_PAR(qsId);
        -:  506:    #endif
        -:  507:
        -:  508:    QF_CRIT_STAT
        -:  509:
        -:  510:    // exit states from the current state to the tran. source state
       50:  511:    QMState const *s = cs;
       50:  512:    int_fast8_t lbound = QMSM_MAX_NEST_DEPTH_; // fixed upper loop bound
       80:  513:    for (; (s != ts) && (lbound > 0); --lbound) {
        -:  514:        // exit action provided in state 's'?
       30:  515:        if (s->exitAction != Q_ACTION_CAST(0)) {
        -:  516:            // execute the exit action
       30:  517:            (void)(*s->exitAction)(me);
        -:  518:
       30:  519:            QS_CRIT_ENTRY();
       30:  520:            QS_MEM_SYS();
       30:  521:            QS_BEGIN_PRE_(QS_QEP_STATE_EXIT, qsId)
       15:  522:                QS_OBJ_PRE_(me);              // this state machine object
       15:  523:                QS_FUN_PRE_(s->stateHandler); // the exited state handler
       15:  524:            QS_END_PRE_()
       30:  525:            QS_MEM_APP();
       30:  526:            QS_CRIT_EXIT();
        -:  527:        }
        -:  528:
       30:  529:        s = s->superstate; // advance to the superstate
        -:  530:    }
       50:  531:    QF_CRIT_ENTRY();
      50*:  532:    Q_ENSURE_INCRIT(890, lbound > 0);
       50:  533:    QF_CRIT_EXIT();
       50:  534:}
        -:  535:
        -:  536://${QEP::QMsm::enterHistory_} ................................................
        -:  537://! @private @memberof QMsm
        8:  538:QState QMsm_enterHistory_(
        -:  539:    QAsm * const me,
        -:  540:    QMState const *const hist,
        -:  541:    uint_fast8_t const qsId)
        -:  542:{
        -:  543:    #ifndef Q_SPY
        -:  544:    Q_UNUSED_PAR(qsId);
        -:  545:    #endif
        -:  546:
        -:  547:    // record the entry path from current state to history
        8:  548:    QMState const *epath[QMSM_MAX_ENTRY_DEPTH_];
        8:  549:    QMState const *s = hist;
        8:  550:    int_fast8_t i = 0; // tran. entry path index
       20:  551:    while ((s != me->state.obj) && (i < (QMSM_MAX_ENTRY_DEPTH_ - 1))) {
       12:  552:        if (s->entryAction != Q_ACTION_CAST(0)) {
       12:  553:            epath[i] = s;
       12:  554:            ++i;
        -:  555:        }
       12:  556:        s = s->superstate;
        -:  557:    }
        -:  558:    QF_CRIT_STAT
        8:  559:    QF_CRIT_ENTRY();
       8*:  560:    Q_ASSERT_INCRIT(910, s == me->state.obj);
        8:  561:    QF_CRIT_EXIT();
        -:  562:
        -:  563:    // retrace the entry path in reverse (desired) order...
       20:  564:    while (i > 0) {
       12:  565:        --i;
       12:  566:        (void)(*epath[i]->entryAction)(me); // run entry action in epath[i]
        -:  567:
       12:  568:        QS_CRIT_ENTRY();
       12:  569:        QS_MEM_SYS();
       12:  570:        QS_BEGIN_PRE_(QS_QEP_STATE_ENTRY, qsId)
        6:  571:            QS_OBJ_PRE_(me);
        6:  572:            QS_FUN_PRE_(epath[i]->stateHandler); // entered state handler
        6:  573:        QS_END_PRE_()
       12:  574:        QS_MEM_APP();
       12:  575:        QS_CRIT_EXIT();
        -:  576:    }
        -:  577:
        8:  578:    me->state.obj = hist; // set current state to the tran. target
        -:  579:
        -:  580:    // initial tran. present?
        8:  581:    QState r;
        8:  582:    if (hist->initAction != Q_ACTION_CAST(0)) {
        4:  583:        r = (*hist->initAction)(me); // execute the tran. action
        4:  584:        QS_CRIT_ENTRY();
        4:  585:        QS_MEM_SYS();
        4:  586:        QS_BEGIN_PRE_(QS_QEP_STATE_INIT, qsId)
        2:  587:            QS_OBJ_PRE_(me); // this state machine object
        2:  588:            QS_FUN_PRE_(hist->stateHandler);                   // source
        2:  589:            QS_FUN_PRE_(me->temp.tatbl->target->stateHandler); // target
        2:  590:        QS_END_PRE_()
        4:  591:        QS_MEM_APP();
        4:  592:        QS_CRIT_EXIT();
        -:  593:    }
        -:  594:    else {
        -:  595:        r = Q_RET_NULL;
        -:  596:    }
        -:  597:
        8:  598:    return r;
        -:  599:}
        -:  600://$enddef${QEP::QMsm} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
