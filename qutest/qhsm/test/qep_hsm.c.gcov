        -:    0:Source:../../../../src/qf/qep_hsm.c
        -:    0:Graph:build/qep_hsm.gcno
        -:    0:Data:build/qep_hsm.gcda
        -:    0:Runs:6
        -:    1://$file${src::qf::qep_hsm.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
        -:    2://
        -:    3:// Model: qpc.qm
        -:    4:// File:  ${src::qf::qep_hsm.c}
        -:    5://
        -:    6:// This code has been generated by QM 7.0.0 <www.state-machine.com/qm>.
        -:    7:// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
        -:    8://
        -:    9:// Copyright (c) General public
        -:   10:// SPDX-License-Identifier: LicenseRef-QL-commercial
        -:   11://
        -:   12:// This generated code is covered by the following QP license:
        -:   13:// License #    : LicenseRef-QL-dual
        -:   14:// Issued to    : General public
        -:   15:// Framework(s) : qpc
        -:   16:// Support ends : 2025-12-31
        -:   17:// License scope:
        -:   18://
        -:   19:// Copyright (C) 2005 Quantum Leaps, LLC. All rights reserved.
        -:   20://
        -:   21://                    Q u a n t u m  L e a P s
        -:   22://                    ------------------------
        -:   23://                    Modern Embedded Software
        -:   24://
        -:   25:// SPDX-License-Identifier: GPL-3.0-or-later OR LicenseRef-QL-commercial
        -:   26://
        -:   27:// The QP/C software is dual-licensed under the terms of the open-source GNU
        -:   28:// General Public License (GPL) or under the terms of one of the closed-
        -:   29:// source Quantum Leaps commercial licenses.
        -:   30://
        -:   31:// Redistributions in source code must retain this top-level comment block.
        -:   32:// Plagiarizing this software to sidestep the license obligations is illegal.
        -:   33://
        -:   34:// NOTE:
        -:   35:// The GPL (see <www.gnu.org/licenses/gpl-3.0>) does NOT permit the
        -:   36:// incorporation of the QP/C software into proprietary programs. Please
        -:   37:// contact Quantum Leaps for commercial licensing options, which expressly
        -:   38:// supersede the GPL and are designed explicitly for licensees interested
        -:   39:// in using QP/C in closed-source proprietary applications.
        -:   40://
        -:   41:// Quantum Leaps contact information:
        -:   42:// <www.state-machine.com/licensing>
        -:   43:// <info@state-machine.com>
        -:   44://
        -:   45://$endhead${src::qf::qep_hsm.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        -:   46:#define QP_IMPL           // this is QP implementation
        -:   47:#include "qp_port.h"      // QP port
        -:   48:#include "qp_pkg.h"       // QP package-scope interface
        -:   49:#include "qsafe.h"        // QP Functional Safety (FuSa) Subsystem
        -:   50:#ifdef Q_SPY              // QS software tracing enabled?
        -:   51:    #include "qs_port.h"  // QS port
        -:   52:    #include "qs_pkg.h"   // QS facilities for pre-defined trace records
        -:   53:#else
        -:   54:    #include "qs_dummy.h" // disable the QS software tracing
        -:   55:#endif // Q_SPY
        -:   56:
        -:   57:Q_DEFINE_THIS_MODULE("qep_hsm")
        -:   58:
        -:   59://$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
        -:   60:// Check for the minimum required QP version
        -:   61:#if (QP_VERSION < 750U) || (QP_VERSION != ((QP_RELEASE^4294967295U)%0x2710U))
        -:   62:#error qpc version 7.5.0 or higher required
        -:   63:#endif
        -:   64://$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        -:   65://$define${QEP::QP_versionStr[16]} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
        -:   66:
        -:   67://${QEP::QP_versionStr[16]} ..................................................
        -:   68:char const QP_versionStr[16] = QP_VERSION_STR;
        -:   69://$enddef${QEP::QP_versionStr[16]} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        -:   70:
        -:   71://============================================================================
        -:   72://! @cond INTERNAL
        -:   73:
        -:   74://$define${QEP::QEvt::reserved_[4]} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
        -:   75:QEvt const QEvt_reserved_[4] = {
        -:   76:    QEVT_INITIALIZER(Q_EMPTY_SIG),
        -:   77:    QEVT_INITIALIZER(Q_ENTRY_SIG),
        -:   78:    QEVT_INITIALIZER(Q_EXIT_SIG),
        -:   79:    QEVT_INITIALIZER(Q_INIT_SIG)
        -:   80:};
        -:   81:
        -:   82://$enddef${QEP::QEvt::reserved_[4]} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        -:   83:
        -:   84:// helper macro to handle reserved event in an QHsm
        -:   85:#define QHSM_RESERVED_EVT_(state_, sig_) \
        -:   86:    ((*(state_))(me, &QEvt_reserved_[(sig_)]))
        -:   87:
        -:   88:// helper macro to trace state entry
        -:   89:#define QS_STATE_ENTRY_(state_, qsId_)         \
        -:   90:    QS_CRIT_ENTRY();                           \
        -:   91:    QS_MEM_SYS();                              \
        -:   92:    QS_BEGIN_PRE_(QS_QEP_STATE_ENTRY, (qsId_)) \
        -:   93:        QS_OBJ_PRE_(me);                       \
        -:   94:        QS_FUN_PRE_(state_);                   \
        -:   95:    QS_END_PRE_()                              \
        -:   96:    QS_MEM_APP();                              \
        -:   97:    QS_CRIT_EXIT()
        -:   98:
        -:   99:// helper macro to trace state exit
        -:  100:#define QS_STATE_EXIT_(state_, qsId_)          \
        -:  101:    QS_CRIT_ENTRY();                           \
        -:  102:    QS_MEM_SYS();                              \
        -:  103:    QS_BEGIN_PRE_(QS_QEP_STATE_EXIT, (qsId_))  \
        -:  104:        QS_OBJ_PRE_(me);                       \
        -:  105:        QS_FUN_PRE_(state_);                   \
        -:  106:    QS_END_PRE_()                              \
        -:  107:    QS_MEM_APP();                              \
        -:  108:    QS_CRIT_EXIT()
        -:  109:
        -:  110://! @endcond
        -:  111:
        -:  112:enum {
        -:  113:    // maximum depth of state nesting in a QHsm (including the top level),
        -:  114:    // must be >= 3
        -:  115:    QHSM_MAX_NEST_DEPTH_ = 6
        -:  116:};
        -:  117:
        -:  118://$define${QEP::QHsm} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
        -:  119:
        -:  120://${QEP::QHsm} ...............................................................
        -:  121:
        -:  122://${QEP::QHsm::ctor} .........................................................
        -:  123://! @protected @memberof QHsm
        6:  124:void QHsm_ctor(QHsm * const me,
        -:  125:    QStateHandler const initial)
        -:  126:{
        6:  127:    static struct QAsmVtable const vtable = { // QAsm virtual table
        -:  128:        &QHsm_init_,
        -:  129:        &QHsm_dispatch_,
        -:  130:        &QHsm_isIn_
        -:  131:    #ifdef Q_SPY
        -:  132:        ,&QHsm_getStateHandler_
        -:  133:    #endif
        -:  134:    };
        -:  135:    // do not call the QAsm_ctor() here
        6:  136:    me->super.vptr      = &vtable;
        6:  137:    me->super.state.fun = Q_STATE_CAST(&QHsm_top);
        6:  138:    me->super.temp.fun  = initial;
        6:  139:}
        -:  140:
        -:  141://${QEP::QHsm::init_} ........................................................
        -:  142://! @private @memberof QHsm
        6:  143:void QHsm_init_(
        -:  144:    QAsm * const me,
        -:  145:    void const * const e,
        -:  146:    uint_fast8_t const qsId)
        -:  147:{
        -:  148:    QF_CRIT_STAT
        -:  149:
        6:  150:    QState r;
        -:  151:
        -:  152:    #ifdef Q_SPY
        6:  153:    QS_CRIT_ENTRY();
        6:  154:    QS_MEM_SYS();
        6:  155:    if ((QS_priv_.flags & 0x01U) == 0U) {
        6:  156:        QS_priv_.flags |= 0x01U;
        6:  157:        r = Q_RET_HANDLED;
        -:  158:    }
        -:  159:    else {
        -:  160:        r = Q_RET_IGNORED;
        -:  161:    }
       6*:  162:    QS_MEM_APP();
       6*:  163:    QS_CRIT_EXIT();
    #####:  164:    if (r == Q_RET_HANDLED) {
        6:  165:        QS_FUN_DICTIONARY(&QHsm_top);
        -:  166:    }
        -:  167:    #else
        -:  168:    Q_UNUSED_PAR(qsId);
        -:  169:    #endif
        -:  170:
        6:  171:    QStateHandler t = me->state.fun;
        -:  172:
        6:  173:    QF_CRIT_ENTRY();
       6*:  174:    Q_REQUIRE_INCRIT(200, (me->vptr != (struct QAsmVtable *)0)
        -:  175:                      && (me->temp.fun != Q_STATE_CAST(0))
        -:  176:                      && (t == Q_STATE_CAST(&QHsm_top)));
        6:  177:    QF_CRIT_EXIT();
        -:  178:
        -:  179:    // execute the top-most initial tran.
        6:  180:    r = (*me->temp.fun)(me, Q_EVT_CAST(QEvt));
        -:  181:
        6:  182:    QF_CRIT_ENTRY();
        -:  183:    // the top-most initial tran. must be taken
       6*:  184:    Q_ASSERT_INCRIT(210, r == Q_RET_TRAN);
        -:  185:
        6:  186:    QS_MEM_SYS();
        6:  187:    QS_BEGIN_PRE_(QS_QEP_STATE_INIT, qsId)
        3:  188:        QS_OBJ_PRE_(me);           // this state machine object
        3:  189:        QS_FUN_PRE_(t);            // the source state
        3:  190:        QS_FUN_PRE_(me->temp.fun); // the target of the initial tran.
        3:  191:    QS_END_PRE_()
        6:  192:    QS_MEM_APP();
        -:  193:
        6:  194:    QF_CRIT_EXIT();
        -:  195:
        -:  196:    // drill down into the state hierarchy with initial transitions...
       12:  197:    do {
       12:  198:        QStateHandler path[QHSM_MAX_NEST_DEPTH_]; // tran. entry path array
       12:  199:        int_fast8_t ip = 0; // tran. entry path index
        -:  200:
       12:  201:        path[0] = me->temp.fun;
       12:  202:        (void)QHSM_RESERVED_EVT_(me->temp.fun, Q_EMPTY_SIG);
        -:  203:        // note: ip is the fixed upper loop bound
       24:  204:        while ((me->temp.fun != t) && (ip < (QHSM_MAX_NEST_DEPTH_ - 1))) {
       12:  205:            ++ip;
       12:  206:            path[ip] = me->temp.fun;
       12:  207:            (void)QHSM_RESERVED_EVT_(me->temp.fun, Q_EMPTY_SIG);
        -:  208:        }
       12:  209:        QF_CRIT_ENTRY();
        -:  210:        // too many state nesting levels or "malformed" HSM
      12*:  211:        Q_ENSURE_INCRIT(220, ip < QHSM_MAX_NEST_DEPTH_);
       12:  212:        QF_CRIT_EXIT();
        -:  213:
       12:  214:        me->temp.fun = path[0];
        -:  215:
        -:  216:        // retrace the entry path in reverse (desired) order...
        -:  217:        // note: ip is the fixed upper loop bound
       24:  218:        do {
        -:  219:            // enter path[ip]
       24:  220:            if (QHSM_RESERVED_EVT_(path[ip], Q_ENTRY_SIG)
        -:  221:                == Q_RET_HANDLED)
        -:  222:            {
       24:  223:                QS_STATE_ENTRY_(path[ip], qsId);
        -:  224:            }
       24:  225:            --ip;
       24:  226:        } while (ip >= 0);
        -:  227:
       12:  228:        t = path[0]; // current state becomes the new source
        -:  229:
       12:  230:        r = QHSM_RESERVED_EVT_(t, Q_INIT_SIG); // execute initial tran.
        -:  231:
        -:  232:    #ifdef Q_SPY
       12:  233:        if (r == Q_RET_TRAN) {
        6:  234:            QS_CRIT_ENTRY();
        6:  235:            QS_MEM_SYS();
        6:  236:            QS_BEGIN_PRE_(QS_QEP_STATE_INIT, qsId)
        3:  237:                QS_OBJ_PRE_(me);           // this state machine object
        3:  238:                QS_FUN_PRE_(t);            // the source state
        3:  239:                QS_FUN_PRE_(me->temp.fun); // the target of the initial tran.
        3:  240:            QS_END_PRE_()
        6:  241:            QS_MEM_APP();
        6:  242:            QS_CRIT_EXIT();
        -:  243:        }
        -:  244:    #endif // Q_SPY
       12:  245:    } while (r == Q_RET_TRAN);
        -:  246:
        6:  247:    QF_CRIT_ENTRY();
        -:  248:
        6:  249:    QS_MEM_SYS();
        6:  250:    QS_BEGIN_PRE_(QS_QEP_INIT_TRAN, qsId)
        3:  251:        QS_TIME_PRE_();    // time stamp
        3:  252:        QS_OBJ_PRE_(me);   // this state machine object
        3:  253:        QS_FUN_PRE_(t);    // the new active state
        3:  254:    QS_END_PRE_()
        6:  255:    QS_MEM_APP();
        -:  256:
        6:  257:    QF_CRIT_EXIT();
        -:  258:
        6:  259:    me->state.fun = t;   // change the current active state
        -:  260:    #ifndef Q_UNSAFE
        6:  261:    me->temp.uint = ~me->state.uint;
        -:  262:    #endif
        6:  263:}
        -:  264:
        -:  265://${QEP::QHsm::dispatch_} ....................................................
        -:  266://! @private @memberof QHsm
       41:  267:void QHsm_dispatch_(
        -:  268:    QAsm * const me,
        -:  269:    QEvt const * const e,
        -:  270:    uint_fast8_t const qsId)
        -:  271:{
        -:  272:    #ifndef Q_SPY
        -:  273:    Q_UNUSED_PAR(qsId);
        -:  274:    #endif
        -:  275:
       41:  276:    QStateHandler s = me->state.fun;
       41:  277:    QStateHandler t = s;
        -:  278:    QF_CRIT_STAT
        -:  279:
       41:  280:    QF_CRIT_ENTRY();
      82*:  281:    Q_REQUIRE_INCRIT(300, QEvt_verify_(e));
      41*:  282:    Q_INVARIANT_INCRIT(302, (s != Q_STATE_CAST(0))
        -:  283:        && (me->state.uint == (uintptr_t)(~me->temp.uint)));
        -:  284:
       41:  285:    QS_MEM_SYS();
       41:  286:    QS_BEGIN_PRE_(QS_QEP_DISPATCH, qsId)
       21:  287:        QS_TIME_PRE_();      // time stamp
       21:  288:        QS_SIG_PRE_(e->sig); // the signal of the event
       21:  289:        QS_OBJ_PRE_(me);     // this state machine object
       21:  290:        QS_FUN_PRE_(s);      // the current state
       21:  291:    QS_END_PRE_()
       41:  292:    QS_MEM_APP();
        -:  293:
       41:  294:    QF_CRIT_EXIT();
        -:  295:
        -:  296:    // process the event hierarchically...
       41:  297:    QState r;
       41:  298:    me->temp.fun = s;
       41:  299:    int_fast8_t ip = QHSM_MAX_NEST_DEPTH_; // fixed upper loop bound
       93:  300:    do {
       93:  301:        s = me->temp.fun;
       93:  302:        r = (*s)(me, e); // invoke state handler s
        -:  303:
       93:  304:        if (r == Q_RET_UNHANDLED) { // unhandled due to a guard?
        -:  305:
        4:  306:            QS_CRIT_ENTRY();
        4:  307:            QS_MEM_SYS();
        4:  308:            QS_BEGIN_PRE_(QS_QEP_UNHANDLED, qsId)
        2:  309:                QS_SIG_PRE_(e->sig); // the signal of the event
        2:  310:                QS_OBJ_PRE_(me);     // this state machine object
        2:  311:                QS_FUN_PRE_(s);      // the current state
        2:  312:            QS_END_PRE_()
        4:  313:            QS_MEM_APP();
        4:  314:            QS_CRIT_EXIT();
        -:  315:
        4:  316:            r = QHSM_RESERVED_EVT_(s, Q_EMPTY_SIG); // superstate of s
        -:  317:        }
        -:  318:
       93:  319:        --ip;
       93:  320:    } while ((r == Q_RET_SUPER) && (ip > 0));
        -:  321:
       41:  322:    QF_CRIT_ENTRY();
      41*:  323:    Q_ENSURE_INCRIT(310, ip > 0);
       41:  324:    QF_CRIT_EXIT();
        -:  325:
       41:  326:    if (r >= Q_RET_TRAN) { // tran. (regular or history) taken?
        -:  327:    #ifdef Q_SPY
       34:  328:        if (r == Q_RET_TRAN_HIST) { // tran. to history?
        8:  329:            QS_CRIT_ENTRY();
        8:  330:            QS_MEM_SYS();
        8:  331:            QS_BEGIN_PRE_(QS_QEP_TRAN_HIST, qsId)
        4:  332:                QS_OBJ_PRE_(me); // this state machine object
        4:  333:                QS_FUN_PRE_(s);            // tran. to history source
        4:  334:                QS_FUN_PRE_(me->temp.fun); // tran. to history target
        4:  335:            QS_END_PRE_()
        8:  336:            QS_MEM_APP();
        8:  337:            QS_CRIT_EXIT();
        -:  338:        }
        -:  339:    #endif // Q_SPY
        -:  340:
       34:  341:        QStateHandler path[QHSM_MAX_NEST_DEPTH_];
       34:  342:        path[0] = me->temp.fun; // tran. target
       34:  343:        path[1] = t; // current state
       34:  344:        path[2] = s; // tran. source
        -:  345:
        -:  346:        // exit current state to tran. source s...
       34:  347:        ip = QHSM_MAX_NEST_DEPTH_; // fixed upper loop bound
       64:  348:        for (; (t != s) && (ip > 0); t = me->temp.fun) {
        -:  349:            // exit from t
       30:  350:            if (QHSM_RESERVED_EVT_(t, Q_EXIT_SIG) == Q_RET_HANDLED) {
       30:  351:                QS_STATE_EXIT_(t, qsId);
        -:  352:                // find superstate of t
       30:  353:                (void)QHSM_RESERVED_EVT_(t, Q_EMPTY_SIG);
        -:  354:            }
       30:  355:            --ip;
        -:  356:        }
       34:  357:        QF_CRIT_ENTRY();
      34*:  358:        Q_ENSURE_INCRIT(320, ip > 0);
       34:  359:        QF_CRIT_EXIT();
        -:  360:
       34:  361:        ip = QHsm_tran_(me, path, qsId); // take the tran.
        -:  362:
        -:  363:        // execute state entry actions in the desired order...
        -:  364:        // note: ip is the fixed upper loop bound
      112:  365:        for (; ip >= 0; --ip) {
        -:  366:            // enter path[ip]
       44:  367:            if (QHSM_RESERVED_EVT_(path[ip], Q_ENTRY_SIG)
        -:  368:                == Q_RET_HANDLED)
        -:  369:            {
       44:  370:                QS_STATE_ENTRY_(path[ip], qsId);
        -:  371:            }
        -:  372:        }
       34:  373:        t = path[0];      // stick the target into register
       34:  374:        me->temp.fun = t; // update the next state
        -:  375:
        -:  376:        // drill into the target hierarchy...
       50:  377:        while (QHSM_RESERVED_EVT_(t, Q_INIT_SIG) == Q_RET_TRAN) {
        -:  378:
       16:  379:            QS_CRIT_ENTRY();
       16:  380:            QS_MEM_SYS();
       16:  381:            QS_BEGIN_PRE_(QS_QEP_STATE_INIT, qsId)
        8:  382:                QS_OBJ_PRE_(me);           // this state machine object
        8:  383:                QS_FUN_PRE_(t);            // the source (pseudo)state
        8:  384:                QS_FUN_PRE_(me->temp.fun); // the target of the tran.
        8:  385:            QS_END_PRE_()
       16:  386:            QS_MEM_APP();
       16:  387:            QS_CRIT_EXIT();
        -:  388:
       16:  389:            ip = 0;
       16:  390:            path[0] = me->temp.fun;
        -:  391:
        -:  392:            // find superstate
       16:  393:            (void)QHSM_RESERVED_EVT_(me->temp.fun, Q_EMPTY_SIG);
        -:  394:
        -:  395:            // note: ip is the fixed upper loop bound
       24:  396:            while ((me->temp.fun != t) && (ip < (QHSM_MAX_NEST_DEPTH_ - 1))) {
        8:  397:                ++ip;
        8:  398:                path[ip] = me->temp.fun;
        -:  399:                // find superstate
        8:  400:                (void)QHSM_RESERVED_EVT_(me->temp.fun, Q_EMPTY_SIG);
        -:  401:            }
       16:  402:            QF_CRIT_ENTRY();
        -:  403:            // too many state nesting levels or "malformed" HSM
      16*:  404:            Q_ENSURE_INCRIT(330, ip < QHSM_MAX_NEST_DEPTH_);
       16:  405:            QF_CRIT_EXIT();
        -:  406:
       16:  407:            me->temp.fun = path[0];
        -:  408:
        -:  409:            // retrace the entry path in reverse (correct) order...
        -:  410:            // note: ip is the fixed upper loop bound
       24:  411:            do {
        -:  412:                // enter path[ip]
       24:  413:                if (QHSM_RESERVED_EVT_(path[ip], Q_ENTRY_SIG)
        -:  414:                    == Q_RET_HANDLED)
        -:  415:                {
       24:  416:                    QS_STATE_ENTRY_(path[ip], qsId);
        -:  417:                }
       24:  418:                --ip;
       24:  419:            } while (ip >= 0);
        -:  420:
       16:  421:            t = path[0]; // current state becomes the new source
        -:  422:        }
        -:  423:
       34:  424:        QS_CRIT_ENTRY();
       34:  425:        QS_MEM_SYS();
       34:  426:        QS_BEGIN_PRE_(QS_QEP_TRAN, qsId)
       17:  427:            QS_TIME_PRE_();      // time stamp
       17:  428:            QS_SIG_PRE_(e->sig); // the signal of the event
       17:  429:            QS_OBJ_PRE_(me);     // this state machine object
       17:  430:            QS_FUN_PRE_(s);      // the source of the tran.
       17:  431:            QS_FUN_PRE_(t);      // the new active state
       17:  432:        QS_END_PRE_()
       34:  433:        QS_MEM_APP();
       34:  434:        QS_CRIT_EXIT();
        -:  435:    }
        -:  436:
        -:  437:    #ifdef Q_SPY
        7:  438:    else if (r == Q_RET_HANDLED) {
        4:  439:        QS_CRIT_ENTRY();
        4:  440:        QS_MEM_SYS();
        4:  441:        QS_BEGIN_PRE_(QS_QEP_INTERN_TRAN, qsId)
        2:  442:            QS_TIME_PRE_();      // time stamp
        2:  443:            QS_SIG_PRE_(e->sig); // the signal of the event
        2:  444:            QS_OBJ_PRE_(me);     // this state machine object
        2:  445:            QS_FUN_PRE_(s);      // the source state
        2:  446:        QS_END_PRE_()
        4:  447:        QS_MEM_APP();
        4:  448:        QS_CRIT_EXIT();
        -:  449:    }
        -:  450:    else {
        3:  451:        QS_CRIT_ENTRY();
        3:  452:        QS_MEM_SYS();
        3:  453:        QS_BEGIN_PRE_(QS_QEP_IGNORED, qsId)
        2:  454:            QS_TIME_PRE_();      // time stamp
        2:  455:            QS_SIG_PRE_(e->sig); // the signal of the event
        2:  456:            QS_OBJ_PRE_(me);     // this state machine object
        2:  457:            QS_FUN_PRE_(me->state.fun); // the current state
        2:  458:        QS_END_PRE_()
        3:  459:        QS_MEM_APP();
        3:  460:        QS_CRIT_EXIT();
        -:  461:    }
        -:  462:    #endif // Q_SPY
        -:  463:
       41:  464:    me->state.fun = t; // change the current active state
        -:  465:    #ifndef Q_UNSAFE
       41:  466:    me->temp.uint = ~me->state.uint;
        -:  467:    #endif
       41:  468:}
        -:  469:
        -:  470://${QEP::QHsm::getStateHandler_} .............................................
        -:  471:#ifdef Q_SPY
        -:  472://! @private @memberof QHsm
        2:  473:QStateHandler QHsm_getStateHandler_(QAsm * const me) {
        2:  474:    return me->state.fun;
        -:  475:}
        -:  476:#endif // def Q_SPY
        -:  477:
        -:  478://${QEP::QHsm::isIn_} ........................................................
        -:  479://! @private @memberof QHsm
       11:  480:bool QHsm_isIn_(
        -:  481:    QAsm * const me,
        -:  482:    QStateHandler const state)
        -:  483:{
        -:  484:    QF_CRIT_STAT
       11:  485:    QF_CRIT_ENTRY();
      11*:  486:    Q_INVARIANT_INCRIT(602, me->state.uint
        -:  487:                       == (uintptr_t)(~me->temp.uint));
       11:  488:    QF_CRIT_EXIT();
        -:  489:
       11:  490:    bool inState = false; // assume that this HSM is not in 'state'
        -:  491:
        -:  492:    // scan the state hierarchy bottom-up
       11:  493:    QStateHandler s = me->state.fun;
       11:  494:    int_fast8_t lbound = QHSM_MAX_NEST_DEPTH_ + 1; // fixed upper loop bound
       11:  495:    QState r = Q_RET_SUPER;
       29:  496:    for (; (r != Q_RET_IGNORED) && (lbound > 0); --lbound) {
       26:  497:        if (s == state) { // do the states match?
        -:  498:            inState = true;  // 'true' means that match found
        -:  499:            break; // break out of the for-loop
        -:  500:        }
        -:  501:        else {
       18:  502:            r = QHSM_RESERVED_EVT_(s, Q_EMPTY_SIG);
       18:  503:            s = me->temp.fun;
        -:  504:        }
        -:  505:    }
        -:  506:
       11:  507:    QF_CRIT_ENTRY();
      11*:  508:    Q_ENSURE_INCRIT(690, lbound > 0);
       11:  509:    QF_CRIT_EXIT();
        -:  510:
        -:  511:    #ifndef Q_UNSAFE
       11:  512:    me->temp.uint = ~me->state.uint;
        -:  513:    #endif
        -:  514:
       11:  515:    return inState; // return the status
        -:  516:}
        -:  517:
        -:  518://${QEP::QHsm::childState} ...................................................
        -:  519://! @public @memberof QHsm
       10:  520:QStateHandler QHsm_childState(QHsm * const me,
        -:  521:    QStateHandler const parent)
        -:  522:{
       10:  523:    QStateHandler child = me->super.state.fun; // start with current state
       10:  524:    bool isFound = false; // start with the child not found
        -:  525:
        -:  526:    // establish stable state configuration
       10:  527:    me->super.temp.fun = child;
       10:  528:    QState r;
       10:  529:    int_fast8_t lbound = QHSM_MAX_NEST_DEPTH_; // fixed upper loop bound
       34:  530:    do {
        -:  531:        // is this the parent of the current child?
       34:  532:        if (me->super.temp.fun == parent) {
        -:  533:            isFound = true; // child is found
        -:  534:            r = Q_RET_IGNORED; // break out of the loop
        -:  535:        }
        -:  536:        else {
       24:  537:            child = me->super.temp.fun;
       24:  538:            r = QHSM_RESERVED_EVT_(me->super.temp.fun, Q_EMPTY_SIG);
        -:  539:        }
       34:  540:        --lbound;
       34:  541:    } while ((r != Q_RET_IGNORED)  // the top state not reached
       34:  542:             && (lbound > 0));
        -:  543:
        -:  544:    #ifndef Q_UNSAFE
       10:  545:    me->super.temp.uint = ~me->super.state.uint;
        -:  546:    #else
        -:  547:    Q_UNUSED_PAR(isFound);
        -:  548:    #endif
        -:  549:
        -:  550:    QF_CRIT_STAT
       10:  551:    QF_CRIT_ENTRY();
        -:  552:    // NOTE: the following postcondition can only succeed when
        -:  553:    // (lbound > 0), so no extra check is necessary.
      10*:  554:    Q_ENSURE_INCRIT(890, isFound);
       10:  555:    QF_CRIT_EXIT();
        -:  556:
       10:  557:    return child;
        -:  558:}
        -:  559:
        -:  560://${QEP::QHsm::tran_} ........................................................
        -:  561://! @private @memberof QHsm
       34:  562:int_fast8_t QHsm_tran_(
        -:  563:    QAsm * const me,
        -:  564:    QStateHandler * const path,
        -:  565:    uint_fast8_t const qsId)
        -:  566:{
        -:  567:    #ifndef Q_SPY
        -:  568:    Q_UNUSED_PAR(qsId);
        -:  569:    #endif
        -:  570:
       34:  571:    int_fast8_t ip = -1; // tran. entry path index
       34:  572:    QStateHandler t = path[0];
       34:  573:    QStateHandler const s = path[2];
        -:  574:    QF_CRIT_STAT
        -:  575:
        -:  576:    // (a) check source==target (tran. to self)...
       34:  577:    if (s == t) {
        -:  578:        // exit source s
        2:  579:        if (QHSM_RESERVED_EVT_(s, Q_EXIT_SIG) == Q_RET_HANDLED) {
        2:  580:            QS_STATE_EXIT_(s, qsId);
        -:  581:        }
        2:  582:        ip = 0; // enter the target
        -:  583:    }
        -:  584:    else {
        -:  585:        // find superstate of target
       32:  586:        (void)QHSM_RESERVED_EVT_(t, Q_EMPTY_SIG);
        -:  587:
       32:  588:        t = me->temp.fun;
        -:  589:
        -:  590:        // (b) check source==target->super...
       32:  591:        if (s == t) {
        -:  592:            ip = 0; // enter the target
        -:  593:        }
        -:  594:        else {
        -:  595:            // find superstate of src
       28:  596:            (void)QHSM_RESERVED_EVT_(s, Q_EMPTY_SIG);
        -:  597:
        -:  598:            // (c) check source->super==target->super...
       28:  599:            if (me->temp.fun == t) {
        -:  600:                // exit source s
       12:  601:                if (QHSM_RESERVED_EVT_(s, Q_EXIT_SIG) == Q_RET_HANDLED) {
       12:  602:                    QS_STATE_EXIT_(s, qsId);
        -:  603:                }
       12:  604:                ip = 0; // enter the target
        -:  605:            }
        -:  606:            else {
        -:  607:                // (d) check source->super==target...
       16:  608:                if (me->temp.fun == path[0]) {
        -:  609:                    // exit source s
        4:  610:                    if (QHSM_RESERVED_EVT_(s, Q_EXIT_SIG) == Q_RET_HANDLED) {
        4:  611:                        QS_STATE_EXIT_(s, qsId);
        -:  612:                    }
        -:  613:                }
        -:  614:                else {
        -:  615:                    // (e) check rest of source==target->super->super..
        -:  616:                    // and store the entry path along the way
       12:  617:                    int_fast8_t iq = 0; // indicate that LCA was found
       12:  618:                    ip = 1; // enter target and its superstate
       12:  619:                    path[1] = t;      // save the superstate of target
       12:  620:                    t = me->temp.fun; // save source->super
        -:  621:
        -:  622:                    // find target->super->super...
        -:  623:                    // note: ip is the fixed upper loop bound
       12:  624:                    QState r = QHSM_RESERVED_EVT_(path[1], Q_EMPTY_SIG);
       12:  625:                    while ((r == Q_RET_SUPER)
       34:  626:                           && (ip < (QHSM_MAX_NEST_DEPTH_ - 1)))
        -:  627:                    {
       22:  628:                        ++ip;
       22:  629:                        path[ip] = me->temp.fun; // store the entry path
       22:  630:                        if (me->temp.fun == s) { // is it the source?
        -:  631:                            iq = 1; // indicate that the LCA found
        -:  632:                            --ip; // do not enter the source
        -:  633:                            r = Q_RET_HANDLED; // terminate the loop
        -:  634:                        }
        -:  635:                        else { // it is not the source, keep going up
       22:  636:                            r = QHSM_RESERVED_EVT_(me->temp.fun, Q_EMPTY_SIG);
        -:  637:                        }
        -:  638:                    }
       12:  639:                    QF_CRIT_ENTRY();
        -:  640:                    // NOTE: The following postcondition succeeds only when
        -:  641:                    // ip < QHSM_MAX_NEST_DEPTH, so no additional check is necessary
        -:  642:                    // too many state nesting levels or "malformed" HSM.
      12*:  643:                    Q_ENSURE_INCRIT(510, r != Q_RET_SUPER);
       12:  644:                    QF_CRIT_EXIT();
        -:  645:
        -:  646:                    // the LCA not found yet?
       12:  647:                    if (iq == 0) {
        -:  648:                        // exit source s
       12:  649:                        if (QHSM_RESERVED_EVT_(s, Q_EXIT_SIG)
        -:  650:                            == Q_RET_HANDLED)
        -:  651:                        {
       12:  652:                            QS_STATE_EXIT_(s, qsId);
        -:  653:                        }
        -:  654:
        -:  655:                        // (f) check the rest of source->super
        -:  656:                        //                  == target->super->super...
       12:  657:                        iq = ip;
       12:  658:                        r = Q_RET_IGNORED; // indicate that the LCA NOT found
        -:  659:                        // note: iq is the fixed upper loop bound
       30:  660:                        do {
       30:  661:                            if (t == path[iq]) { // is this the LCA?
        6:  662:                                r = Q_RET_HANDLED; // indicate the LCA found
        6:  663:                                ip = iq - 1; // do not enter the LCA
        6:  664:                                iq = -1; // cause termination of the loop
        -:  665:                            }
        -:  666:                            else {
       24:  667:                                --iq; // try lower superstate of target
        -:  668:                            }
       30:  669:                        } while (iq >= 0);
        -:  670:
        -:  671:                        // the LCA not found yet?
       12:  672:                        if (r != Q_RET_HANDLED) {
        -:  673:                            // (g) check each source->super->...
        -:  674:                            // for each target->super...
        -:  675:                            r = Q_RET_IGNORED; // keep looping
        -:  676:                            int_fast8_t lbound = QHSM_MAX_NEST_DEPTH_;
        8:  677:                            do {
        -:  678:                                // exit from t
        8:  679:                                if (QHSM_RESERVED_EVT_(t, Q_EXIT_SIG)
        -:  680:                                    == Q_RET_HANDLED)
        -:  681:                                {
        8:  682:                                    QS_STATE_EXIT_(t, qsId);
        -:  683:                                    // find superstate of t
        8:  684:                                    (void)QHSM_RESERVED_EVT_(t, Q_EMPTY_SIG);
        -:  685:                                }
        8:  686:                                t = me->temp.fun; // set to super of t
        8:  687:                                iq = ip;
       16:  688:                                do {
        -:  689:                                    // is this the LCA?
       16:  690:                                    if (t == path[iq]) {
        6:  691:                                        ip = iq - 1; // do not enter the LCA
        6:  692:                                        iq = -1;     // break out of inner loop
        6:  693:                                        r = Q_RET_HANDLED; // break outer loop
        -:  694:                                    }
        -:  695:                                    else {
       10:  696:                                        --iq;
        -:  697:                                    }
       16:  698:                                } while (iq >= 0);
        -:  699:
        8:  700:                                --lbound;
        8:  701:                            } while ((r != Q_RET_HANDLED) && (lbound > 0));
        6:  702:                            QF_CRIT_ENTRY();
       6*:  703:                            Q_ENSURE_INCRIT(530, lbound > 0);
        6:  704:                            QF_CRIT_EXIT();
        -:  705:                        }
        -:  706:                    }
        -:  707:                }
        -:  708:            }
        -:  709:        }
        -:  710:    }
      12*:  711:    QF_CRIT_ENTRY();
      34*:  712:    Q_ENSURE_INCRIT(590, ip < QHSM_MAX_NEST_DEPTH_);
       34:  713:    QF_CRIT_EXIT();
       34:  714:    return ip;
        -:  715:}
        -:  716:
        -:  717://${QEP::QHsm::top} ..........................................................
        -:  718://! @protected @memberof QAsm
       18:  719:QState QHsm_top(QHsm const * const me,
        -:  720:    QEvt const * const e)
        -:  721:{
       18:  722:    Q_UNUSED_PAR(me);
       18:  723:    Q_UNUSED_PAR(e);
       18:  724:    return Q_RET_IGNORED; // the top state ignores all events
        -:  725:}
        -:  726://$enddef${QEP::QHsm} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
